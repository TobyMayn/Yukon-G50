Index: main.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//#include <iostream>\r\n#include <string.h>\r\n//#include <cstring>\r\n#include <stdio.h>\r\n#include <malloc.h>\r\n#include <stdbool.h>\r\n\r\ntypedef struct card Card;\r\n\r\n// Array of the different suits, Clubs, Diamonds, Hearts and Spades\r\nconst char suits[] = {'C', 'D', 'H', 'S'};\r\nchar ranks[] = {'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K'};\r\n// Foundations\r\nCard *foundations[4];\r\n\r\n//Columns\r\nCard *columns[7];\r\n\r\n//Head for initial linked list\r\nCard *head = NULL;\r\n\r\nstruct card {\r\n    Card *prev;\r\n    Card *next;\r\n    char rank;\r\n    char suit;\r\n};\r\n\r\n\r\nCard *new_card(char rank, char suit){\r\n    Card *card = (Card *)malloc(sizeof(Card));\r\n    card->prev = NULL;\r\n    card->next = NULL;\r\n    card->rank = rank;\r\n    card->suit = suit;\r\n    return card;\r\n}\r\nCard *default_deck(){\r\n    //Initialize deck, with a dummy bottom card\r\n    Card *deck = new_card('B', 'B');\r\n    Card *prev = deck;\r\n    for (int suit = 0; suit < 4; suit++) {\r\n        for (int rank = 0; rank < 13; rank++) {\r\n            Card *card = new_card(ranks[rank], suits[suit]);\r\n            prev->next = card;\r\n            card->prev = prev;\r\n            prev = card;\r\n        }\r\n    }\r\n    return deck;\r\n}\r\n\r\n//Still needs work - currently only takes input file and prints content to terminal\r\nCard *load_deck(char* filename){\r\n    FILE* ptr;\r\n    char ch;\r\n\r\n    ptr = fopen(filename, \"r\");\r\n\r\n    if (NULL == ptr) {\r\n        printf(\"File doesn't exist\");\r\n    }\r\n\r\n    // Add dummy card to bottom\r\n    Card *deck = new_card('B', 'B');\r\n    Card *prev = deck;\r\n    head = deck;\r\n\r\n    char input[3]; // char array to hold line characters for input\r\n\r\n    // Do-while that reads an entire line, creates a new card and adds it to the deck\r\n    do {\r\n        for (int i = 0; i < 3; ++i) {\r\n            ch = fgetc(ptr);\r\n            input[i] = ch;\r\n        }\r\n        Card *card = new_card(input[0], input[1]);\r\n        prev->next = card;\r\n        card->prev = prev;\r\n        prev = card;\r\n\r\n        // Checking if character is not EOF.\r\n        // If it is EOF stop reading.\r\n    } while (ch != EOF);\r\n\r\n    // Closing the file\r\n    fclose(ptr);\r\n    return deck;\r\n}\r\nvoid *save_cards(Card *deck, char* filename){\r\n    FILE* ptr;\r\n\r\n    ptr = fopen(filename, \"w\");\r\n    do {\r\n        deck = deck->next;\r\n        fprintf(ptr,\"%c%c\\n\", deck->rank, deck->suit);\r\n    }while(deck->next != NULL);\r\n\r\n\r\n    // Closing the file\r\n    fclose(ptr);\r\n}\r\n\r\nvoid error_message(){\r\n    printf(\"\\nInvalid move..!\\n\");\r\n}\r\n\r\n// Helper method for interleave_shuffle\r\nCard *split_deck(Card *deck, int amount){\r\n    Card *temp_deck = deck;\r\n    // Loop to find spot to split\r\n    for (int i = 0; i <= amount; ++i) {\r\n        temp_deck = temp_deck->next;\r\n    }\r\n    //Emil//Bliver prev og next ikke slettet for den samme node her? (115-117) Ville man ikke skulle gøre sådan her?\r\n    // [120][100] - [90][70] - [100][130]\r\n\r\n    Card *holder = temp_deck->prev;\r\n    holder->next = NULL;\r\n    // [120][NULL] - [90][70] - [100][130]\r\n    temp_deck->prev = NULL;\r\n    // [120][NULL] - [NULL][70] - [100][130]\r\n\r\n    temp_deck->prev = NULL;\r\n    Card *part = temp_deck->next; // Variable for holding split part of deck\r\n    temp_deck->prev->next = NULL;\r\n    return part;\r\n}\r\n\r\n\r\nCard *interleave_shuffle(Card *deck, int amount){\r\n    Card *new_deck = deck; // Variable for holding interleaved deck\r\n    Card *part = split_deck(deck, amount);\r\n\r\n    // Add dummy card to new card deck\r\n    new_deck->next = NULL; // Set next pointer to NULL\r\n    deck = deck->next; // Deck now has first actual card\r\n    //deck->prev = NULL;\r\n\r\n    while(deck->next != NULL){\r\n        if(part->next == NULL){\r\n            new_deck->next = deck;\r\n            deck->prev = new_deck;\r\n            return new_deck;\r\n        }\r\n\r\n        // Add card from first pile to new_deck\r\n        new_deck->next = deck;\r\n        new_deck->next->prev = new_deck;\r\n        new_deck = new_deck->next;\r\n\r\n\r\n        if(part->next != NULL){\r\n            //Add card from second pile to new_deck\r\n            new_deck->next = part;\r\n            new_deck->next->prev = new_deck;\r\n            new_deck = new_deck->next;\r\n        }\r\n        // Update pointers\r\n        deck->prev = NULL;\r\n        part->prev = NULL;\r\n        deck = deck->next;\r\n        part = part->next;\r\n    }\r\n    new_deck->next = part;\r\n    part->prev = new_deck;\r\n\r\n    return new_deck;\r\n}\r\n\r\nCard *random_shuffle(Card *deck){\r\n    return deck;\r\n}\r\n\r\n//method to find pile ie foundation or column, to start searching for a card.\r\n//If the given pile doesn't exist the method will return a null pointer.\r\nCard *get_pile(char rank,char suit){\r\n    Card *temp = NULL;\r\n    for (int i = 0; i < ((sizeof(columns) / sizeof(columns[0])) + sizeof(foundations) / sizeof(foundations[0])) ; ++i) {\r\n        if (i >= 7){\r\n            if(foundations[i % 7]->rank == rank && foundations[i % 7]->suit == suit)\r\n                temp = foundations[i % 7];\r\n        }\r\n        else if(columns[i % 7]->rank == rank && columns[i % 7]->suit == suit){\r\n            temp = columns[i];\r\n            break;\r\n        }\r\n    }\r\n    return temp;\r\n}\r\n\r\nCard *find_card(char rank,char suit,Card *ptr){\r\n    while(ptr->next != NULL && (ptr->rank != rank && ptr->suit != suit)){\r\n        ptr = ptr->next;\r\n    }\r\n    if(ptr->rank != rank && ptr->suit != suit || ptr->prev == NULL){ //Checks if the specified card, is the dummy card + checking if the card exists\r\n        error_message();\r\n        return NULL;\r\n    }\r\n    return ptr;\r\n}\r\n\r\n//the foundations will not have a predefined suit. The suit of the foundation will be defined by the first card moved to it.\r\nbool move_to_foundation(Card *card, Card *toPile) {\r\n    bool possMove = false;\r\n    if(card->next != NULL)//checks if we're trying to move more than one card.\r\n        return possMove;\r\n\r\n    if (toPile->prev == NULL){//Checks if the foundation is empty.\r\n        if(card->rank == ranks[0])//if the foundation is empty check if the card is an Ace.\r\n            possMove = true;\r\n    }else{\r\n        //find topcard in foundation\r\n        while(toPile->next != NULL){\r\n            toPile = toPile->next;\r\n        }\r\n        int i = 0;\r\n        while(ranks[i] != card->rank){ //Find the index for the cards rank.\r\n            i++;\r\n        }\r\n\r\n        if(ranks[i-1] == toPile->rank){//checks if the topcard is one rank less, than the card we with to move.\r\n            if(card->suit == toPile->suit)//checks for same suit.\r\n                possMove = true;\r\n        }\r\n    }\r\n    return possMove;\r\n}\r\n\r\nbool valid_move(Card *card,Card *topile){\r\n    bool valid = false;\r\n    int i = 0;\r\n\r\n    if(topile->rank == foundations[0]->rank){\r\n        return move_to_foundation(card,topile);\r\n    }\r\n\r\n    while(topile->next != NULL){\r\n        topile = topile->next;\r\n    }\r\n    while(ranks[i] != card->rank){\r\n        i++;\r\n    }\r\n    if(i < 12 && ranks[i+1] == topile->rank){\r\n        if(card->suit != topile->suit)\r\n            valid = true;\r\n    }\r\n    if(i == 12){\r\n        //checks if pile is empty for king move\r\n        if(topile->prev == NULL)\r\n            valid = true;\r\n    }\r\n    return valid;\r\n}\r\n\r\nvoid move_specific(const char *command,Card *pointer) {\r\n    //checks if card exists in pile / list\r\n    pointer = find_card(command[3],command[4],pointer);\r\n    if(pointer == NULL){\r\n        error_message();\r\n        return;\r\n    }\r\n\r\n    //finds the column or foundation specified in the command.\r\n    Card *to = get_pile(command[7],command[8]);\r\n    if(to == NULL){\r\n        error_message();\r\n        return;\r\n    }\r\n\r\n    while(to->next != NULL){\r\n        to = to->next;\r\n    }\r\n    //from this point we have found the card from a pile, and the pile it's supposed to go to.\r\n    //now we check if the move is valid.\r\n    if(valid_move(pointer,to)){\r\n        //moves card from a stack\r\n        Card *temp = pointer->prev;\r\n        temp->next = NULL;\r\n\r\n        pointer->prev = to;\r\n        to->next = pointer;\r\n    }\r\n}\r\n\r\n\r\nvoid pile_to_pile(const char *command,Card *pointer) {\r\n    Card *to = get_pile(command[4],command[5]);\r\n    if (to == NULL){\r\n        error_message();\r\n        return;\r\n    }\r\n\r\n    while(pointer->next != NULL){\r\n        pointer = pointer->next;\r\n    }\r\n    while(to->next != NULL){\r\n        to = to->next;\r\n    }\r\n\r\n    Card *temp;\r\n    if(valid_move(pointer,to)){\r\n        temp = pointer->prev;\r\n        temp->next = NULL; //Dereferencing card from old list.\r\n\r\n        pointer->prev =  to;\r\n        to->next = pointer;//Referencing card in new list.\r\n    }\r\n\r\n}\r\n\r\nvoid move(const char *command, int strlen) {\r\n    Card *temp = get_pile(command[0], command[1]);//gets pointer of list to move from\r\n    if (temp == NULL) {\r\n        error_message();//if the get_pile method returns a null pointer we return to caller with error message\r\n        return;\r\n    }\r\n\r\n    int type = 2;\r\n    if (strlen == 6)\r\n        type = 0;\r\n    else if (strlen == 9)\r\n        type = 1;\r\n\r\n\r\n    switch (type) {\r\n        case 0 :\r\n            pile_to_pile(command, temp);\r\n            break;\r\n        case 1:\r\n            move_specific(command, temp);\r\n            break;\r\n        case 2:\r\n            error_message();\r\n            return;\r\n    }\r\n\r\n}\r\n\r\n\r\nvoid show(){\r\n    Card *temp = head;\r\n    printf(\"\\n\\tC1\\tC2\\tC3\\tC4\\tC5\\tC6\\tC7\\n\");\r\n    int i = 0;\r\n    int j = 1;\r\n    int f;\r\n    char s[2];\r\n    while(temp->next != NULL){\r\n        if(i % 7 == 0) {\r\n            if(j % 2 == 0 && j != 1) {\r\n                f = j / 2;\r\n                s[0] = 'F';\r\n                s[1] = f + '0';\r\n                printf(\"\\t[]\\t%s\",s);\r\n            }\r\n            printf(\"\\n\\t\");\r\n            j++;\r\n        }\r\n        temp = temp->next;\r\n        printf(\"%c%c\\t\",temp->rank, temp->suit);\r\n\r\n        i++;\r\n    }\r\n    printf(\"\\n\\n\");\r\n}\r\n\r\nint find_longest_list(){\r\n    int max_length = 0;\r\n    //temp pointer to iterate through lists\r\n    Card *temp;\r\n    //finding the longest linked list.\r\n    for (int i = 0; i < sizeof(columns) / sizeof(columns[0]); ++i) {\r\n        int j = 0;\r\n        temp = columns[i];\r\n        while(temp->next != NULL){\r\n            temp = temp->next;\r\n            j++;\r\n        }\r\n        if(j > max_length)\r\n            max_length = j;\r\n    }\r\n    return max_length;\r\n}\r\n\r\n//method for printing the contents of each list\r\nvoid print_gamestate(){\r\n    Card *placeholder[7];\r\n\r\n    //copying head pointers to foundations linked lists over to another array.\r\n    for (int i = 0; i < sizeof(placeholder) / sizeof(placeholder[0]); ++i) {\r\n        placeholder[i] = columns[i];\r\n    }\r\n\r\n    int max_length = find_longest_list();\r\n    if(max_length < 8)\r\n        max_length = 8;\r\n\r\n    printf(\"\\n\");\r\n    for (int i = 0; i < sizeof(placeholder) / sizeof(placeholder[0]); ++i) {//Prints the dummy cards for all columns\r\n        printf(\"\\t%c%c\",placeholder[i]->rank,placeholder[i]->suit);\r\n    }\r\n    printf(\"\\n\");\r\n    int f = 1;\r\n    Card* foundation_temp;\r\n    //printing all cards in the column or and empty space if there is no card.\r\n    for (int i = 0; i < max_length; ++i) {\r\n        printf(\"\\n\\t\");\r\n        for (int j = 0; j < sizeof(placeholder) / sizeof(placeholder[0]); ++j) {\r\n            if (placeholder[j]->next != NULL){\r\n                placeholder[j] = placeholder[j]->next;\r\n                printf(\"%c%c\\t\",placeholder[j]->rank, placeholder[j]->suit);\r\n            }\r\n            else\r\n                printf(\"  \\t\");\r\n        }\r\n        //printing foundation cards for evert second row.\r\n        f++;\r\n        if (f % 2 == 0 && ((f/2) - 1) < (sizeof(foundations) / sizeof(foundations[0]))){\r\n            foundation_temp = foundations[(f / 2) - 1];\r\n            while (foundation_temp->next != NULL) {\r\n                foundation_temp = foundation_temp->next;\r\n            }\r\n            if(foundation_temp->prev == NULL){\r\n                printf(\"[]\\tF%c\",(f / 2) + '0');\r\n            }else{\r\n                printf(\"%c%c\\t%c%c\",foundation_temp->rank,foundation_temp->suit,foundations[(f / 2) - 1]->rank,foundations[(f / 2) - 1]->suit);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\nconst char* get_input() {\r\n    char input[127];\r\n    printf(\"Enter command: \");\r\n    scanf(\"%s\", &input);\r\n    return input;\r\n}\r\n\r\nvoid setup_columns_foundations(){\r\n    for (int i = 0; i < 4; ++i) {\r\n        foundations[i] = new_card('F', i + 1 +'0'); //dummy card\r\n    }\r\n    for (int i = 0; i < 7; ++i) {\r\n        columns[i] = new_card('C', i + 1 + '0'); //dummy card\r\n    }\r\n}\r\n\r\nint find_string_length(const char *string){\r\n    int size = 0;\r\n    for (int i = 0; i < strlen(string); ++i) {\r\n        if(string[i] != ' ') {\r\n            size++;\r\n        }\r\n    }\r\n    return size;\r\n}\r\n\r\nint main() {\r\n\r\n//    setup_columns_foundations();\r\n//    Card *first_card = columns[0];\r\n//    Card *card  = new_card('A', 'C');\r\n//    first_card->next = card;\r\n//    //Test to show how it could be made in conole\r\n//    printf(\"\\tC1\\tC2\\tC3\\tC4\\tC5\\tC6\\tC7\\n\\n\");\r\n//    printf(\"\\t%c%c\\t[]\\t[]\\t[]\\t[]\\t[]\\t[]\\t\\tF1\\n\", first_card->next->rank, first_card->next->suit);\r\n//    printf(\"\\t  \\t7H\\t[]\\t[]\\t[]\\t[]\\t[]\\t\\t\\n\");\r\n//    printf(\"\\t  \\t  \\t5H\\t[]\\t[]\\t[]\\t[]\\t\\tF2\\n\");\r\n//    printf(\"\\t  \\t  \\t  \\t6C\\t[]\\t[]\\t[]\\t\\t\\n\");\r\n//    printf(\"\\t  \\t  \\t  \\t  \\t6S\\t[]\\t[]\\t\\tF3\\n\");\r\n//    printf(\"\\t  \\t  \\t  \\t  \\t  \\tQC\\t[]\\t\\t\\n\");\r\n//    printf(\"\\t  \\t  \\t  \\t  \\t  \\t  \\tKH\\t\\tF4\\n\");\r\n//    printf(\"\\t  \\t  \\t  \\t  \\t  \\t  \\t  \\t\\t\\n\");\r\n\r\n//test for move method\r\n/*\r\nsetup_columns_foundations();\r\n    Card *tempCard = new_card('K','H');\r\n    columns[4]->next = tempCard;\r\n    tempCard->prev = columns[4];\r\n    card *tempcard2 = new_card('A','H');\r\n    columns[0]->next = tempcard2;\r\n    tempcard2->prev = columns[0];\r\n    print_gamestate();\r\n    char moveF[] = \"C5:KH->C6  \";\r\n    move(moveF, find_string_length(moveF));\r\n    char moveE[] = \"C1->F1\";\r\n    move(moveE, find_string_length(moveE));\r\n    print_gamestate();\r\n    */\r\n\r\n    //Test for show method\r\n    head = load_deck(\"C:\\\\DTU\\\\2-semester\\\\MaskinarProgrammering\\\\Yukon\\\\Yukon-G50\\\\Test_input.txt\");\r\n    show();\r\n\r\n    // Test to print all cards, if no input file is provided\r\n    Card *deck = default_deck();\r\n\r\n//    Card *play_deck = interleave_shuffle(deck, 20);\r\n//    do {\r\n//        play_deck = play_deck->next;\r\n//        printf(\"%c%c\\n\",play_deck->rank, play_deck->suit);\r\n//    }  while (play_deck->next != NULL);\r\n//\r\n//\r\n//    do {\r\n//        printf(\"%c%c\\n\",first_card->rank, first_card->suit);\r\n//        first_card = first_card->next;\r\n//        printf(\"%c%c\\n\",first_card->rank, first_card->suit);\r\n//    }  while (first_card->next != NULL);\r\n\r\n    //clear screen\r\n    //system(\"cls\");\r\n\r\n    //save_cards(deck, \"C:\\\\DTU\\\\2-semester\\\\MaskinarProgrammering\\\\Yukon\\\\YukonS-G50\\\\Test1_input.txt\");\r\n\r\n\r\n\r\n    return 0;\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.c b/main.c
--- a/main.c	(revision a333d5630e213a1ff918371681ab83fc13873c3f)
+++ b/main.c	(date 1651828823229)
@@ -334,9 +334,7 @@
             error_message();
             return;
     }
-
 }
-
 
 void show(){
     Card *temp = head;
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"CMakeRunConfigurationManager\" shouldGenerate=\"true\" shouldDeleteObsolete=\"true\">\r\n    <generated>\r\n      <config projectName=\"Yukon_G50\" targetName=\"Yukon_G50\" />\r\n    </generated>\r\n  </component>\r\n  <component name=\"CMakeSettings\">\r\n    <configurations>\r\n      <configuration PROFILE_NAME=\"Debug\" ENABLED=\"true\" CONFIG_NAME=\"Debug\" />\r\n    </configurations>\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"63b0d282-5cb0-4c80-a4ec-0961bdf29197\" name=\"Changes\" comment=\"updated version of project\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/cmake-build-debug/.ninja_deps\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/cmake-build-debug/.ninja_deps\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/cmake-build-debug/.ninja_log\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/cmake-build-debug/.ninja_log\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/cmake-build-debug/Testing/Temporary/LastTest.log\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/cmake-build-debug/Testing/Temporary/LastTest.log\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/main.c\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/main.c\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"ClangdSettings\">\r\n    <option name=\"formatViaClangd\" value=\"false\" />\r\n  </component>\r\n  <component name=\"ExecutionTargetManager\" SELECTED_TARGET=\"CMakeBuildProfile:Debug\" />\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\r\n      <map>\r\n        <entry key=\"$PROJECT_DIR$\" value=\"main\" />\r\n      </map>\r\n    </option>\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectApplicationVersion\">\r\n    <option name=\"ide\" value=\"CLion\" />\r\n    <option name=\"majorVersion\" value=\"2021\" />\r\n    <option name=\"minorVersion\" value=\"3.4\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"28mLQm1QvPbHb664MwL8dgXKwjh\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">\r\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\r\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\r\n    <property name=\"RunOnceActivity.cidr.known.project.marker\" value=\"true\" />\r\n    <property name=\"WebServerToolWindowFactoryState\" value=\"false\" />\r\n    <property name=\"cf.first.check.clang-format\" value=\"false\" />\r\n    <property name=\"cidr.known.project.marker\" value=\"true\" />\r\n    <property name=\"cmake.loaded.for.project\" value=\"true\" />\r\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$/../YukonS-G50\" />\r\n  </component>\r\n  <component name=\"RunManager\">\r\n    <configuration default=\"true\" type=\"CLionExternalRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\">\r\n      <method v=\"2\">\r\n        <option name=\"CLION.EXTERNAL.BUILD\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"Yukon_G50\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"Yukon_G50\" TARGET_NAME=\"Yukon_G50\" CONFIG_NAME=\"Debug\" RUN_TARGET_PROJECT_NAME=\"Yukon_G50\" RUN_TARGET_NAME=\"Yukon_G50\">\r\n      <method v=\"2\">\r\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"63b0d282-5cb0-4c80-a4ec-0961bdf29197\" name=\"Changes\" comment=\"\" />\r\n      <created>1651816801136</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1651816801136</updated>\r\n      <workItem from=\"1651816802845\" duration=\"4596000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"Project created\">\r\n      <created>1651820463956</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1651820463956</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"Project created\">\r\n      <created>1651820818537</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1651820818537</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"updated version of project\">\r\n      <created>1651824571272</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1651824571272</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"4\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"Project created\" />\r\n    <MESSAGE value=\"updated version of project\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"updated version of project\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision a333d5630e213a1ff918371681ab83fc13873c3f)
+++ b/.idea/workspace.xml	(date 1651831020474)
@@ -1,5 +1,8 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
+  <component name="AutoImportSettings">
+    <option name="autoReloadType" value="SELECTIVE" />
+  </component>
   <component name="CMakeRunConfigurationManager" shouldGenerate="true" shouldDeleteObsolete="true">
     <generated>
       <config projectName="Yukon_G50" targetName="Yukon_G50" />
@@ -11,11 +14,8 @@
     </configurations>
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="63b0d282-5cb0-4c80-a4ec-0961bdf29197" name="Changes" comment="updated version of project">
+    <list default="true" id="63b0d282-5cb0-4c80-a4ec-0961bdf29197" name="Changes" comment="Project created">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/cmake-build-debug/.ninja_deps" beforeDir="false" afterPath="$PROJECT_DIR$/cmake-build-debug/.ninja_deps" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/cmake-build-debug/.ninja_log" beforeDir="false" afterPath="$PROJECT_DIR$/cmake-build-debug/.ninja_log" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/cmake-build-debug/Testing/Temporary/LastTest.log" beforeDir="false" afterPath="$PROJECT_DIR$/cmake-build-debug/Testing/Temporary/LastTest.log" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/main.c" beforeDir="false" afterPath="$PROJECT_DIR$/main.c" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
@@ -49,16 +49,14 @@
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent">
-    <property name="RunOnceActivity.OpenProjectViewOnStart" value="true" />
-    <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />
-    <property name="RunOnceActivity.cidr.known.project.marker" value="true" />
-    <property name="WebServerToolWindowFactoryState" value="false" />
-    <property name="cf.first.check.clang-format" value="false" />
-    <property name="cidr.known.project.marker" value="true" />
-    <property name="cmake.loaded.for.project" value="true" />
-    <property name="last_opened_file_path" value="$PROJECT_DIR$/../YukonS-G50" />
-  </component>
+  <component name="PropertiesComponent"><![CDATA[{
+  "keyToString": {
+    "node.js.detected.package.eslint": "true",
+    "node.js.detected.package.tslint": "true",
+    "node.js.selected.package.eslint": "(autodetect)",
+    "node.js.selected.package.tslint": "(autodetect)"
+  }
+}]]></component>
   <component name="RunManager">
     <configuration default="true" type="CLionExternalRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" ELEVATE="false" USE_EXTERNAL_CONSOLE="false" PASS_PARENT_ENVS_2="true">
       <method v="2">

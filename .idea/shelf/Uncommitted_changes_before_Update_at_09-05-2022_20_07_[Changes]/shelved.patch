Index: main.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//#include <iostream>\r\n#include <string.h>\r\n//#include <cstring>\r\n#include <stdio.h>\r\n#include <malloc.h>\r\n#include <stdbool.h>\r\n#include <time.h>\r\n\r\ntypedef struct card Card;\r\ntypedef struct moves Moves;\r\n\r\n// Array of the different suits, Clubs, Diamonds, Hearts and Spades\r\nconst char suits[] = {'C', 'D', 'H', 'S'};\r\nchar ranks[] = {'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K'};\r\n\r\n//Array consisting of the initial number of cards turned face down;\r\nint facedown[7];\r\n\r\nCard *deck;\r\n// Foundations\r\nCard *foundations[4];\r\n//Columns\r\nCard *columns[7];\r\n//header pointing at moves struct, used in undo command\r\nMoves *latest;\r\n\r\nstruct card {\r\n    Card *prev;\r\n    Card *next;\r\n    char rank;\r\n    char suit;\r\n};\r\n\r\nCard *new_card(char rank, char suit){\r\n    Card *card = (Card *)malloc(sizeof(Card));\r\n    card->prev = NULL;\r\n    card->next = NULL;\r\n    card->rank = rank;\r\n    card->suit = suit;\r\n    return card;\r\n}\r\n\r\nstruct moves {\r\n    Moves *prev;\r\n    char *command;\r\n};\r\n\r\n//moves will be implemented as a stack, hence why there is only a pointer to a prev node.\r\nMoves *new_move(char *command){\r\n    Moves *moves = (Moves *)malloc(sizeof(Moves));\r\n    moves->prev = NULL;\r\n    moves->command = command;\r\n    return moves;\r\n}\r\n\r\nvoid update_undo_header(char *command){\r\n    Moves *prev = latest;\r\n    latest = new_move(command);\r\n    latest->prev = prev;\r\n}\r\n\r\nMoves *initialize_undo(){\r\n    Moves *moves = new_move(\"UNDO\");\r\n    return moves;\r\n}\r\n\r\nCard *default_deck(){\r\n    //Initialize deck, with a dummy bottom card\r\n    Card *head = new_card('B', 'B');\r\n    Card *current = head;\r\n    for (int suit = 0; suit < 4; suit++) {\r\n        for (int rank = 0; rank < 13; rank++) {\r\n            Card *newCard = new_card(ranks[rank], suits[suit]);\r\n            current->next = newCard;\r\n            head->prev = newCard;\r\n            newCard->prev = current;\r\n            newCard->next = head;\r\n            current = newCard;\r\n        }\r\n    }\r\n    return head;\r\n}\r\n\r\n//Still needs work - currently only takes input file and prints content to terminal\r\nCard *load_deck(char* filename){\r\n    FILE* ptr;\r\n    char ch;\r\n\r\n    ptr = fopen(filename, \"r\");\r\n\r\n    if (NULL == ptr) {\r\n        printf(\"File doesn't exist\");\r\n    }\r\n\r\n    // Add dummy card to bottom\r\n    Card *head = new_card('B', 'B');\r\n    Card *current = head;\r\n\r\n    char input[3]; // char array to hold line characters for input\r\n\r\n    // Do-while that reads an entire line, creates a new card and adds it to the deck\r\n    do {\r\n        for (int i = 0; i < 3; ++i) {\r\n            ch = fgetc(ptr);\r\n            input[i] = ch;\r\n        }\r\n        Card *newCard = new_card(input[0], input[1]);\r\n        current->next = newCard;\r\n        head->prev = newCard;\r\n        newCard->prev = current;\r\n        newCard->next = head;\r\n        current = newCard;\r\n\r\n        // Checking if character is not EOF.\r\n        // If it is EOF stop reading.\r\n    } while (ch != EOF);\r\n\r\n    // Closing the file\r\n    fclose(ptr);\r\n    return head;\r\n}\r\nvoid *save_cards(Card *deck, char* filename){\r\n    FILE* ptr;\r\n\r\n    ptr = fopen(filename, \"w\");\r\n    do {\r\n        deck = deck->next;\r\n        fprintf(ptr,\"%c%c\\n\", deck->rank, deck->suit);\r\n    }while(deck->next != NULL);\r\n\r\n\r\n    // Closing the file\r\n    fclose(ptr);\r\n}\r\n\r\nvoid update_facedown(int index){\r\n    if(facedown[index] != 0)\r\n        facedown[index]--;\r\n}\r\n\r\nvoid error_message(){\r\n    printf(\"\\nInvalid move..!\\n\");\r\n}\r\n\r\nint find_string_length(const char *string){\r\n    int size = 0;\r\n    for (int i = 0; i < strlen(string); ++i) {\r\n        if(string[i] != ' ') {\r\n            size++;\r\n        }\r\n    }\r\n    return size;\r\n}\r\n\r\n//method to find pile ie foundation or column, to start searching for a card.\r\n//If the given pile doesn't exist the method will return a null pointer.\r\nCard *get_pile(char rank,char suit){\r\n    Card *temp = NULL;\r\n    for (int i = 0; i < ((sizeof(columns) / sizeof(columns[0])) + sizeof(foundations) / sizeof(foundations[0])) ; ++i) {\r\n        if (i >= 7){\r\n            if(foundations[i % 7]->rank == rank && foundations[i % 7]->suit == suit)\r\n                temp = foundations[i % 7];\r\n        }\r\n        else if(columns[i % 7]->rank == rank && columns[i % 7]->suit == suit){\r\n            temp = columns[i];\r\n            break;\r\n        }\r\n    }\r\n    return temp;\r\n}\r\n\r\nCard *find_card(char rank,char suit,Card *ptr){\r\n    Card *pile = ptr;\r\n    while(ptr->next != pile || (ptr->rank != rank && ptr->suit != suit)){\r\n        ptr = ptr->next;\r\n        if(ptr->rank == rank && ptr->suit == suit)\r\n            return ptr;\r\n    }\r\n    if(ptr->rank != rank && ptr->suit != suit || (ptr->prev == pile && ptr->next == pile)){ //Checks if the specified card, is the dummy card + checking if the card exists\r\n        error_message();\r\n        return NULL;\r\n    }\r\n    return ptr;\r\n}\r\n\r\nvoid move_bunch(Card *from, Card *frompile, Card *to, Card *topile){\r\n    Card *temp = from;\r\n\r\n    while(temp->next != frompile){\r\n        temp = temp->next;\r\n    }\r\n\r\n    from->prev->next = frompile;\r\n    frompile->prev = from->prev;\r\n\r\n    topile->prev = temp;\r\n    temp->next = topile;\r\n    from->prev = to;\r\n    to->next = from;\r\n}\r\n\r\nvoid move_card(Card *from,Card *to){\r\n    Card *temp = from;\r\n    temp->prev->next = temp->next;\r\n    temp->next->prev = temp->prev;\r\n\r\n    temp->next = to->next;\r\n    to->next = temp;\r\n    temp->prev = to;\r\n}\r\n\r\n// Helper method for interleave_shuffle\r\nCard *split_deck(Card *deck, int amount){\r\n    Card *temp_deck = deck;\r\n\r\n    //First actual card in deck\r\n    temp_deck = temp_deck->next;\r\n    // Loop to find spot to split\r\n    for (int i = 0; i < amount; ++i) {\r\n        temp_deck = temp_deck->next;\r\n    }\r\n\r\n    temp_deck->prev->next = NULL;\r\n    temp_deck->prev = NULL;\r\n\r\n    Card *part = temp_deck; // Variable for holding split part of deck\r\n    return part;\r\n}\r\n\r\n\r\nCard *interleave_shuffle(Card *head, int amount){\r\n    Card *new_deck_head = new_card('B', 'B'); // Variable for holding interleaved deck\r\n    Card *new_deck = new_deck_head;\r\n    Card *part;\r\n    //If amount == 0, just return original deck\r\n    if (amount > 52) {\r\n        printf(\"Amount too large, pick lower amount!!\");\r\n        return new_deck;\r\n    }\r\n    if (amount == 0 || amount == 52){\r\n        return head;\r\n    }\r\n\r\n    part = split_deck(head, amount);\r\n\r\n    Card *deck_next = head->next;\r\n    deck_next->prev = NULL;\r\n    // Deck now has first actual card\r\n\r\n    while(deck_next != NULL && deck_next->rank != 'B'){\r\n        // Add card from first pile to new_deck\r\n        new_deck->next = new_card(deck_next->rank, deck_next->suit);\r\n        new_deck->next->prev = new_deck;\r\n        new_deck = new_deck->next;\r\n\r\n        // Update first pile pointer\r\n        deck_next = deck_next->next;\r\n\r\n        //Check if card is the last card in second pile\r\n        if(part->next == NULL || part->next->rank == 'B'){\r\n            //Add last card in part\r\n            new_deck->next = new_card(part->rank, part->suit);\r\n            new_deck->next->prev = new_deck;\r\n            new_deck = new_deck->next;\r\n\r\n            //Add the rest of the other cards in the first pile\r\n            new_deck->next = deck_next;\r\n            new_deck->next->prev = new_deck;\r\n\r\n            // Update pointers for head and tail\r\n            Card *placeholder = new_deck_head;\r\n            for (int i = 0; i < 52; ++i) {\r\n                placeholder = placeholder->next;\r\n            }\r\n            new_deck_head->prev = placeholder;\r\n            placeholder->next = new_deck_head;\r\n            return new_deck_head;\r\n        }\r\n\r\n\r\n        if(part->next != NULL && part->next->rank != 'B' ){\r\n            //Add card from second pile to new_deck\r\n            new_deck->next = new_card(part->rank, part->suit);\r\n            new_deck->next->prev = new_deck;\r\n            new_deck = new_deck->next;\r\n\r\n            // update second pile pointer\r\n            part = part->next;\r\n        }\r\n    }\r\n    new_deck->next = part;\r\n    new_deck->next->prev = new_deck;\r\n\r\n    // Update pointers for head and tail\r\n    Card *placeholder = new_deck_head;\r\n    for (int i = 0; i < 52; ++i) {\r\n        placeholder = placeholder->next;\r\n    }\r\n    new_deck_head->prev = placeholder;\r\n    placeholder->next = new_deck_head;\r\n\r\n    return new_deck_head;\r\n}\r\n\r\nCard *random_shuffle(Card *deck){\r\n    int n = 2;\r\n    if(!deck->next){\r\n        return deck;\r\n    }\r\n    srand(time(NULL)); // Seeds rand() once, generating better random numbers.\r\n\r\n    Card *shuffled_deck = deck->next; // Add first card from deck to shuffled_deck\r\n    Card *current_card = deck->next->next; // Add second card from deck to current card\r\n    Card *next_card = deck->next->next->next; // Add third card from deck to next_card\r\n    shuffled_deck->next = NULL;\r\n    shuffled_deck->prev = NULL;\r\n\r\n    while (current_card->rank != 'B'){\r\n        Card *next_next_card = next_card->next;\r\n        int random = rand() % n;\r\n        if (random == 0){\r\n            shuffled_deck->prev = current_card;\r\n            current_card->next = shuffled_deck;\r\n            current_card->prev = NULL;\r\n            shuffled_deck = current_card;\r\n        }\r\n        else {\r\n            Card *placeholder = shuffled_deck;\r\n            for (int i = 1; i < random; ++i) {\r\n                placeholder = placeholder->next;\r\n            }\r\n            if (placeholder->next != NULL) {\r\n                placeholder->next->prev = current_card;\r\n            }\r\n            current_card->next = placeholder->next;\r\n            placeholder->next = current_card;\r\n            current_card->prev = placeholder;\r\n\r\n        }\r\n        current_card = next_card;\r\n        next_card = next_next_card; // Update next_card\r\n        n++;\r\n    }\r\n    //Add dummy card in start of shuffled deck\r\n    shuffled_deck->prev = deck;\r\n    deck->next = shuffled_deck;\r\n    deck->prev = NULL;\r\n    shuffled_deck = deck;\r\n\r\n    // Update pointers for head and tail\r\n    Card *placeholder = shuffled_deck;\r\n    for (int i = 0; i < 52; ++i) {\r\n        placeholder = placeholder->next;\r\n    }\r\n    shuffled_deck->prev = placeholder;\r\n    placeholder->next = shuffled_deck;\r\n\r\n    return shuffled_deck;\r\n}\r\n\r\nvoid undo(){\r\n    if(latest->command == \"UNDO\"){\r\n        error_message();\r\n        return;\r\n    }//checks for dummy card\r\n\r\n    char *command = latest->command;\r\n    Card *topile = get_pile(command[0],command[1]);\r\n\r\n    int strlen = find_string_length(command);\r\n\r\n    if(strlen == 9) {\r\n        Card *frompile = get_pile(command[7], command[8]);\r\n        Card *fromcard = find_card(command[3],command[4],frompile);\r\n        Card *tocard = topile;\r\n        while(tocard->next != topile) {\r\n            tocard = tocard->next;\r\n        }\r\n        move_bunch(fromcard,frompile,tocard,topile);\r\n    }\r\n    else{\r\n        Card *frompile = get_pile(command[4],command[5]);\r\n        Card *from = frompile;\r\n        Card *to = topile;\r\n        while(from->next != frompile){\r\n            from = from->next;\r\n        }\r\n        while(to->next != topile){\r\n            to = to->next;\r\n        }\r\n        move_card(from,to);\r\n    }\r\n    //making the pointer point to the latest move command.\r\n    Moves *temp = latest;\r\n    latest = temp->prev;\r\n    free(temp); //deleting the node from memory.\r\n}\r\n\r\n//the foundations will not have a predefined suit. The suit of the foundation will be defined by the first card moved to it.\r\nbool move_to_foundation(Card *card,Card *topilepos, Card *toPile) {\r\n    bool possMove = false;\r\n    if(card->next->rank != 'C')//checks if we're trying to move more than one card.\r\n        return possMove;\r\n\r\n    if (toPile->next == toPile){//Checks if the foundation is empty.\r\n        if(card->rank == ranks[0])//if the foundation is empty check if the card is an Ace.\r\n            possMove = true;\r\n    }else{\r\n        int i = 0;\r\n        while(ranks[i] != card->rank){ //Find the index for the cards rank.\r\n            i++;\r\n        }\r\n\r\n        if(ranks[i-1] == topilepos->rank){//checks if the topcard is one rank less, than the card we with to move.\r\n            if(card->suit == topilepos->suit)//checks for same suit.\r\n                possMove = true;\r\n        }\r\n    }\r\n    return possMove;\r\n}\r\n\r\nbool valid_move(Card *cardToMove, Card *topilepos, Card *topile){\r\n    bool valid = false;\r\n    int i = 0;\r\n\r\n    if(topile->rank == foundations[0]->rank){\r\n        return move_to_foundation(cardToMove,topilepos,topile);\r\n    }\r\n\r\n    while(ranks[i] != cardToMove->rank){\r\n        i++;\r\n    }\r\n    if(i < 12 && ranks[i+1] == topilepos->rank){\r\n        if(cardToMove->suit != topilepos->suit)\r\n            valid = true;\r\n    }\r\n    if(i == 12){\r\n        //checks if pile is empty for king move\r\n        if(topile->next == topile)\r\n            valid = true;\r\n    }\r\n    return valid;\r\n}\r\n\r\nvoid move_specific(char *command,Card *cardtomove) {\r\n    Card *frompile = cardtomove;\r\n    //checks if card exists in pile / list\r\n    cardtomove = find_card(command[3], command[4], cardtomove);\r\n    if(cardtomove == NULL){\r\n        error_message();\r\n        return;\r\n    }\r\n\r\n    //finds the column or foundation specified in the command.\r\n    Card *to = get_pile(command[7],command[8]);\r\n    if(to == NULL){\r\n        error_message();\r\n        return;\r\n    }\r\n\r\n    Card *tonode = to;\r\n    while(tonode->next != to){\r\n        tonode = tonode->next;\r\n    }\r\n    //cardtomove this point we have found the card cardtomove a pile, and the pile it's supposed to go to.\r\n    //now we check if the move is valid.\r\n    if(valid_move(cardtomove, tonode, to)){\r\n        move_bunch(cardtomove,frompile,tonode,to);\r\n        update_undo_header(command);\r\n    }\r\n    else\r\n        error_message();\r\n}\r\n\r\n\r\nvoid pile_to_pile(char *command,Card *pointer) {\r\n    Card *from = pointer;\r\n    Card *to = get_pile(command[4],command[5]);\r\n    Card *pile = to;\r\n    if (to == NULL){\r\n        error_message();\r\n        return;\r\n    }\r\n\r\n    while(from->next != pointer){\r\n        from = from->next;\r\n    }\r\n    while(to->next != pile){\r\n        to = to->next;\r\n    }\r\n\r\n    Card *temp;\r\n    if(valid_move(from,to,pile)){\r\n        move_card(from,to);\r\n        update_undo_header(command);\r\n    }\r\n\r\n}\r\n\r\nvoid move(const char *command) {\r\n    Card *pile = get_pile(command[0], command[1]);//gets pointer of list to move from\r\n    if (pile == NULL) {\r\n        error_message();//if the get_pile method returns a null pointer we return to caller with error message\r\n        return;\r\n    }\r\n    if(pile->next == pile){//checks if pile is empty\r\n        error_message();\r\n        return;\r\n    }\r\n\r\n    int strlen = find_string_length(command);\r\n\r\n    switch (strlen) {\r\n        case 6 :\r\n            pile_to_pile(command, pile);\r\n            break;\r\n        case 9:\r\n            move_specific(command, pile);\r\n            break;\r\n        default:\r\n            error_message();\r\n            return;\r\n    }\r\n}\r\n\r\n//Showmethod only works on unshuffled deck\r\nvoid show(){\r\n    Card *temp = deck;\r\n    printf(\"\\n\\tC1\\tC2\\tC3\\tC4\\tC5\\tC6\\tC7\\n\");\r\n    int i = 0;\r\n    int j = 1;\r\n    int f;\r\n    char s[2];\r\n    while(temp->next->rank != 'B'){\r\n        if(i % 7 == 0) {\r\n            if(j % 2 == 0 && j != 1) {\r\n                f = j / 2;\r\n                s[0] = 'F';\r\n                s[1] = f + '0';\r\n                printf(\"\\t[]\\t%s\",s);\r\n            }\r\n            printf(\"\\n\\t\");\r\n            j++;\r\n        }\r\n        temp = temp->next;\r\n        printf(\"%c%c\\t\",temp->rank, temp->suit);\r\n\r\n        i++;\r\n    }\r\n    printf(\"\\n\\n\");\r\n}\r\n\r\nint find_longest_list(){\r\n    int max_length = 0;\r\n    //temp pointer to iterate through lists\r\n    Card *temp;\r\n    //finding the longest linked list.\r\n    for (int i = 0; i < sizeof(columns) / sizeof(columns[0]); ++i) {\r\n        int j = 0;\r\n        temp = columns[i];\r\n        while(temp->next != columns[i]){\r\n            temp = temp->next;\r\n            j++;\r\n        }\r\n        if(j > max_length)\r\n            max_length = j;\r\n    }\r\n    return max_length;\r\n}\r\n\r\n//method for printing the contents of each list\r\nvoid print_gamestate(){\r\n    Card *placeholder[7];\r\n\r\n    //copying head pointers to foundations linked lists over to another array.\r\n    for (int i = 0; i < sizeof(placeholder) / sizeof(placeholder[0]); ++i) {\r\n        placeholder[i] = columns[i];\r\n    }\r\n\r\n    int max_length = find_longest_list(); //finding the length of the longest list, to know how much to print to the console\r\n    if(max_length < 8) //if the length is less than 8, it is set to 8, so the foundations will be printed.\r\n        max_length = 8;\r\n\r\n    printf(\"\\n\");\r\n    for (int i = 0; i < sizeof(placeholder) / sizeof(placeholder[0]); ++i) {//Prints the dummy cards for all columns\r\n        printf(\"\\t%c%c\",placeholder[i]->rank,placeholder[i]->suit);\r\n    }\r\n    printf(\"\\n\");\r\n    int f = 1;\r\n    Card* foundation_temp;\r\n    //printing one card at a time from each column. If there is no card, an empty space will be printed.\r\n    for (int i = 0; i < max_length; ++i) {\r\n        printf(\"\\n\\t\");\r\n        for (int j = 0; j < sizeof(placeholder) / sizeof(placeholder[0]); ++j) {\r\n            //Checks that next card is not the last card\r\n            if (placeholder[j]->next != columns[j]) {\r\n                placeholder[j] = placeholder[j]->next;\r\n                //checks that the facedown cards has been turned or not\r\n                if(facedown[j] >= i + 1){\r\n                    //checks whether a card is supposed to be turned\r\n                    if(facedown[j] == i + 1 && placeholder[j]->next == columns[j]) {\r\n                        //Decrements the amount of facedown cards for the given column.\r\n                        update_facedown(j);\r\n                        printf(\"%c%c\\t\", placeholder[j]->rank, placeholder[j]->suit);\r\n                    }\r\n                    else\r\n                        //prints facedown card\r\n                        printf(\"[]\\t\");\r\n                }\r\n                else\r\n                    //if we are past the facedown cards just print the card if there is a nextcard\r\n                    printf(\"%c%c\\t\", placeholder[j]->rank, placeholder[j]->suit);\r\n            }\r\n            else\r\n                printf(\"  \\t\");\r\n        }\r\n        //printing foundation cards for evert second row.\r\n        f++;\r\n        if (f % 2 == 0 && ((f/2) - 1) < (sizeof(foundations) / sizeof(foundations[0]))){\r\n            foundation_temp = foundations[(f / 2) - 1];\r\n            while (foundation_temp->next != foundations[(f / 2) - 1]) {\r\n                foundation_temp = foundation_temp->next;\r\n            }\r\n            if(foundations[(f / 2) - 1]->next == foundations[(f / 2) - 1]){\r\n                printf(\"[]\\tF%c\",(f / 2) + '0');\r\n            }else{\r\n                printf(\"%c%c\\t%c%c\",foundation_temp->rank,foundation_temp->suit,foundations[(f / 2) - 1]->rank,foundations[(f / 2) - 1]->suit);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nconst char* get_input() {\r\n    char input[127];\r\n    printf(\"Enter command: \");\r\n    scanf(\"%s\", &input);\r\n    return input;\r\n}\r\n\r\n//Distributes the cards on to the starting piles.\r\nvoid distribute_cards(Card* play_deck){\r\n    bool distributed = false;\r\n    Card *temp;\r\n    Card *column_temp;\r\n\r\n    if(!distributed){\r\n        int pile_lengths[7] = {1,6,7,8,9,10,11}; //array determines how many cards should be placed in a column\r\n        for (int i = 0; play_deck->next->rank != 'B'; ++i) {\r\n            for (int j = 0; j < sizeof(pile_lengths) / sizeof(pile_lengths[0]); ++j) {\r\n                //if the right amount of cards have already been placed in a column, the following will iterate to the next column\r\n                if(pile_lengths[j] > i && play_deck->next->rank != 'B') {\r\n                    play_deck = play_deck->next;\r\n                    temp = play_deck;\r\n                    column_temp = columns[j];\r\n                    while(column_temp->next->rank != 'C'){\r\n                        column_temp = column_temp->next;\r\n                    }\r\n                    //erasing node from play_deck\r\n                    play_deck = temp->prev;\r\n                    temp->prev->next = temp->next;\r\n                    temp->next->prev = temp->prev;\r\n\r\n                    column_temp->next = temp;\r\n                    temp->prev = column_temp;\r\n                    temp->next = columns[j];\r\n                }\r\n            }\r\n        }\r\n        distributed = true;\r\n    }\r\n\r\n}\r\n\r\nvoid setup_columns_foundations(){\r\n    for (int i = 0; i < 4; ++i) {\r\n        foundations[i] = new_card('F', i + 1 +'0'); //dummy card\r\n        foundations[i]->prev = foundations[i];\r\n        foundations[i]->next = foundations[i];\r\n    }\r\n    for (int i = 0; i < 7; ++i) {\r\n        columns[i] = new_card('C', i + 1 + '0'); //dummy card\r\n        columns[i]->prev = columns[i];\r\n        columns[i]->next = columns[i];\r\n        facedown[i] = i;\r\n    }\r\n}\r\n\r\nint main() {\r\n\r\n//   system(\"cls\"); Clears console\r\n    //Test for show method\r\n//    head = load_deck(\"C:\\\\DTU\\\\2-semester\\\\MaskinarProgrammering\\\\Yukon\\\\Yukon-G50\\\\Test_input.txt\");\r\n//    show();\r\n\r\n    latest = initialize_undo();\r\n\r\n    Moves *mower = new_move(\"UNDO\");\r\n\r\n    // Test to print all cards, if no input file is provided\r\n    deck = default_deck();\r\n    show();\r\n\r\n    Card *play_deck = interleave_shuffle(deck, 25);\r\n    Card *prev = play_deck->prev;\r\n    setup_columns_foundations();\r\n    distribute_cards(play_deck);\r\n    print_gamestate();\r\n\r\n    move(\"C1->F1\");\r\n    print_gamestate();\r\n    undo();\r\n    print_gamestate();\r\n    move(\"F1->C2\");\r\n    print_gamestate();\r\n    move(\"C7->C1\");\r\n    move(\"C3:8C->C4\");\r\n    print_gamestate();\r\n    move(\"C7:QD->C1\");\r\n    print_gamestate();\r\n\r\n    do {\r\n        play_deck = play_deck->next;\r\n        printf(\"%c%c\\n\",play_deck->rank, play_deck->suit);\r\n    }  while (play_deck->next != NULL && play_deck->next->rank != *\"B\");\r\n    printf(\"\\nLast card is: %c%c\\n First card is: %c%c\", prev->rank, prev->suit, prev->next->rank, prev->next->suit);\r\n\r\n\r\n//    do {\r\n//        printf(\"%c%c\\n\",first_card->rank, first_card->suit);\r\n//        first_card = first_card->next;\r\n//        printf(\"%c%c\\n\",first_card->rank, first_card->suit);\r\n//    }  while (first_card->next != NULL);\r\n\r\n    //clear screen\r\n    //system(\"cls\");\r\n\r\n    //save_cards(deck, \"C:\\\\DTU\\\\2-semester\\\\MaskinarProgrammering\\\\Yukon\\\\YukonS-G50\\\\Test1_input.txt\");\r\n\r\n    return 0;\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.c b/main.c
--- a/main.c	(revision a9a6fd861767d0b4d1eafb30618f6c5b6a588b11)
+++ b/main.c	(date 1652100077879)
@@ -699,13 +699,11 @@
     // Test to print all cards, if no input file is provided
     deck = default_deck();
     show();
-
+    setup_columns_foundations();
     Card *play_deck = interleave_shuffle(deck, 25);
     Card *prev = play_deck->prev;
-    setup_columns_foundations();
     distribute_cards(play_deck);
-    print_gamestate();
-
+    
     move("C1->F1");
     print_gamestate();
     undo();
Index: cmake-build-debug/Testing/Temporary/LastTest.log
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>Start testing: May 09 14:21 Rom, sommertid\r\n----------------------------------------------------------\r\nEnd testing: May 09 14:21 Rom, sommertid\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cmake-build-debug/Testing/Temporary/LastTest.log b/cmake-build-debug/Testing/Temporary/LastTest.log
--- a/cmake-build-debug/Testing/Temporary/LastTest.log	(revision a9a6fd861767d0b4d1eafb30618f6c5b6a588b11)
+++ b/cmake-build-debug/Testing/Temporary/LastTest.log	(date 1652100027962)
@@ -1,3 +1,3 @@
-Start testing: May 09 14:21 Rom, sommertid
+Start testing: May 09 14:40 Rom, sommertid
 ----------------------------------------------------------
-End testing: May 09 14:21 Rom, sommertid
+End testing: May 09 14:40 Rom, sommertid
Index: cmake-build-debug/.ninja_log
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># ninja log v5\r\n2\t1603\t6737604171262752\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n1604\t3020\t6737604199743101\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t154\t6737609184571021\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n155\t546\t6737609188380820\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t228\t6737610181632705\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n228\t418\t6737610183482864\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t558\t6737610544223146\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n559\t743\t6737610546132824\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t151\t6737611234963544\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n151\t294\t6737611236324955\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t1124\t6737613535937519\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n1124\t1530\t6737613539986686\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t149\t6737617633072504\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n150\t329\t6737617634813025\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t1044\t6737618114052811\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n1044\t1566\t6737618118735014\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t223\t6737618762997405\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n224\t970\t6737618769640362\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t145\t6737627312143455\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n146\t814\t6737627318716057\tYukon_G50.exe\td2b83a946ec9e300\r\n3\t424\t6737628780935716\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n425\t1317\t6737628789941643\tYukon_G50.exe\td2b83a946ec9e300\r\n3\t164\t6737630452320648\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n165\t308\t6737630453736847\tYukon_G50.exe\td2b83a946ec9e300\r\n3\t763\t6737634197196800\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n763\t1298\t6737634203904129\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t153\t6737634483951609\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n153\t658\t6737634488359825\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t135\t6737640907666035\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n135\t925\t6737640910937294\tYukon_G50.exe\td2b83a946ec9e300\r\n4\t177\t6737641430758782\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n178\t2130\t6737641442307896\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t125\t6737641812049128\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n126\t667\t6737641817065717\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t141\t6737642512393786\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n142\t835\t6737642518582323\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t189\t6737642887938108\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n190\t357\t6737642889643740\tYukon_G50.exe\td2b83a946ec9e300\r\n3\t1892\t6737650246502906\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n1893\t2449\t6737650253598422\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t126\t6737650454367479\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n127\t255\t6737650455624114\tYukon_G50.exe\td2b83a946ec9e300\r\n3\t212\t6737652636683890\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n213\t589\t6737652640688257\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t1036\t6737652896885584\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n1037\t1525\t6737652907388339\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t164\t6737654401831707\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n165\t342\t6737654403407493\tYukon_G50.exe\td2b83a946ec9e300\r\n3\t348\t6737661760602519\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n349\t2266\t6737661770585824\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t210\t6737662726826227\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n212\t881\t6737662732840140\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t585\t6737989783001104\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n586\t1264\t6737989789922593\tYukon_G50.exe\td2b83a946ec9e300\r\n1\t141\t6738007271134609\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n142\t957\t6738007278275515\tYukon_G50.exe\td2b83a946ec9e300\r\n3\t404\t6738010176163643\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n405\t843\t6738010180292605\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t194\t6738012099191753\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n195\t1230\t6738012106432385\tYukon_G50.exe\td2b83a946ec9e300\r\n1\t373\t6738016955801922\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n374\t1097\t6738016963202137\tYukon_G50.exe\td2b83a946ec9e300\r\n1\t123\t6738019383227250\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n124\t248\t6738019384453972\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t142\t6738019506105307\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n143\t669\t6738019508808078\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t125\t6738020806454958\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n126\t269\t6738020807731545\tYukon_G50.exe\td2b83a946ec9e300\r\n2\t126\t6738021048021399\tCMakeFiles/Yukon_G50.dir/main.c.obj\tc417855f6526839a\r\n127\t548\t6738021051093187\tYukon_G50.exe\td2b83a946ec9e300\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cmake-build-debug/.ninja_log b/cmake-build-debug/.ninja_log
--- a/cmake-build-debug/.ninja_log	(revision a9a6fd861767d0b4d1eafb30618f6c5b6a588b11)
+++ b/cmake-build-debug/.ninja_log	(date 1652100027727)
@@ -69,3 +69,7 @@
 126	269	6738020807731545	Yukon_G50.exe	d2b83a946ec9e300
 2	126	6738021048021399	CMakeFiles/Yukon_G50.dir/main.c.obj	c417855f6526839a
 127	548	6738021051093187	Yukon_G50.exe	d2b83a946ec9e300
+2	165	6738031480030749	CMakeFiles/Yukon_G50.dir/main.c.obj	c417855f6526839a
+166	354	6738031481885779	Yukon_G50.exe	d2b83a946ec9e300
+2	147	6738032275592328	CMakeFiles/Yukon_G50.dir/main.c.obj	c417855f6526839a
+148	310	6738032277118242	Yukon_G50.exe	d2b83a946ec9e300
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"CMakeRunConfigurationManager\">\r\n    <generated>\r\n      <config projectName=\"Yukon_G50\" targetName=\"Yukon_G50\" />\r\n    </generated>\r\n  </component>\r\n  <component name=\"CMakeSettings\">\r\n    <configurations>\r\n      <configuration PROFILE_NAME=\"Debug\" ENABLED=\"true\" CONFIG_NAME=\"Debug\" />\r\n    </configurations>\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"63b0d282-5cb0-4c80-a4ec-0961bdf29197\" name=\"Changes\" comment=\"gamelogic fixed\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/cmake-build-debug/.ninja_deps\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/cmake-build-debug/.ninja_deps\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/cmake-build-debug/.ninja_log\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/cmake-build-debug/.ninja_log\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/cmake-build-debug/Testing/Temporary/LastTest.log\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/cmake-build-debug/Testing/Temporary/LastTest.log\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/main.c\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/main.c\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"ClangdSettings\">\r\n    <option name=\"formatViaClangd\" value=\"false\" />\r\n  </component>\r\n  <component name=\"ExecutionTargetManager\" SELECTED_TARGET=\"CMakeBuildProfile:Debug\" />\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\r\n      <map>\r\n        <entry key=\"$PROJECT_DIR$\" value=\"main\" />\r\n      </map>\r\n    </option>\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectApplicationVersion\">\r\n    <option name=\"ide\" value=\"CLion\" />\r\n    <option name=\"majorVersion\" value=\"2021\" />\r\n    <option name=\"minorVersion\" value=\"3.4\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"28mLQm1QvPbHb664MwL8dgXKwjh\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"RunOnceActivity.cidr.known.project.marker\": \"true\",\r\n    \"WebServerToolWindowFactoryState\": \"false\",\r\n    \"cf.first.check.clang-format\": \"false\",\r\n    \"cidr.known.project.marker\": \"true\",\r\n    \"cmake.loaded.for.project\": \"true\",\r\n    \"node.js.detected.package.eslint\": \"true\",\r\n    \"node.js.detected.package.tslint\": \"true\",\r\n    \"node.js.selected.package.eslint\": \"(autodetect)\",\r\n    \"node.js.selected.package.tslint\": \"(autodetect)\"\r\n  }\r\n}]]></component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"Yukon_G50\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"Yukon_G50\" TARGET_NAME=\"Yukon_G50\" CONFIG_NAME=\"Debug\" RUN_TARGET_PROJECT_NAME=\"Yukon_G50\" RUN_TARGET_NAME=\"Yukon_G50\">\r\n      <method v=\"2\">\r\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"63b0d282-5cb0-4c80-a4ec-0961bdf29197\" name=\"Changes\" comment=\"\" />\r\n      <created>1651816801136</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1651816801136</updated>\r\n      <workItem from=\"1651816802845\" duration=\"4653000\" />\r\n      <workItem from=\"1651824995381\" duration=\"233000\" />\r\n      <workItem from=\"1651825476070\" duration=\"297000\" />\r\n      <workItem from=\"1651825921121\" duration=\"4994000\" />\r\n      <workItem from=\"1651842195150\" duration=\"3959000\" />\r\n      <workItem from=\"1651994419726\" duration=\"1197000\" />\r\n      <workItem from=\"1652011086391\" duration=\"7314000\" />\r\n      <workItem from=\"1652091448129\" duration=\"7902000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"Project created\">\r\n      <created>1651820463956</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1651820463956</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"Project created\">\r\n      <created>1651820818537</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1651820818537</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"updated version of project\">\r\n      <created>1651824571272</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1651824571272</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"Added Test_input file\">\r\n      <created>1651824952769</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1651824952769</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"interleave_shuffle done\">\r\n      <created>1651933280586</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1651933280586</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00006\" summary=\"random_shuffle() done\">\r\n      <created>1651941011566</created>\r\n      <option name=\"number\" value=\"00006\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1651941011566</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00007\" summary=\"Added functionality that updates head and tail pointers in shuffle methods\">\r\n      <created>1651995531433</created>\r\n      <option name=\"number\" value=\"00007\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1651995531433</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00008\" summary=\"Added method to distribute the cards to the starting piles\">\r\n      <created>1652052743695</created>\r\n      <option name=\"number\" value=\"00008\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1652052743695</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00009\" summary=\"Added method to distribute the cards to the starting piles\">\r\n      <created>1652053078954</created>\r\n      <option name=\"number\" value=\"00009\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1652053078954</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00010\" summary=\"Added method to distribute the cards to the starting piles\">\r\n      <created>1652057665038</created>\r\n      <option name=\"number\" value=\"00010\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1652057665038</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00011\" summary=\"gamelogic fixed\">\r\n      <created>1652059889848</created>\r\n      <option name=\"number\" value=\"00011\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1652059889848</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"12\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"Project created\" />\r\n    <MESSAGE value=\"updated version of project\" />\r\n    <MESSAGE value=\"Added Test_input file\" />\r\n    <MESSAGE value=\"interleave_shuffle done\" />\r\n    <MESSAGE value=\"random_shuffle() done\" />\r\n    <MESSAGE value=\"Added functionality that updates head and tail pointers in shuffle methods\" />\r\n    <MESSAGE value=\"Added method to distribute the cards to the starting piles\" />\r\n    <MESSAGE value=\"gamelogic fixed\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"gamelogic fixed\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision a9a6fd861767d0b4d1eafb30618f6c5b6a588b11)
+++ b/.idea/workspace.xml	(date 1652119656658)
@@ -14,7 +14,7 @@
     </configurations>
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="63b0d282-5cb0-4c80-a4ec-0961bdf29197" name="Changes" comment="gamelogic fixed">
+    <list default="true" id="63b0d282-5cb0-4c80-a4ec-0961bdf29197" name="Changes" comment="Added the undo function">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/cmake-build-debug/.ninja_deps" beforeDir="false" afterPath="$PROJECT_DIR$/cmake-build-debug/.ninja_deps" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/cmake-build-debug/.ninja_log" beforeDir="false" afterPath="$PROJECT_DIR$/cmake-build-debug/.ninja_log" afterDir="false" />
@@ -87,7 +87,7 @@
       <workItem from="1651842195150" duration="3959000" />
       <workItem from="1651994419726" duration="1197000" />
       <workItem from="1652011086391" duration="7314000" />
-      <workItem from="1652091448129" duration="7902000" />
+      <workItem from="1652091448129" duration="8874000" />
     </task>
     <task id="LOCAL-00001" summary="Project created">
       <created>1651820463956</created>
@@ -166,7 +166,14 @@
       <option name="project" value="LOCAL" />
       <updated>1652059889848</updated>
     </task>
-    <option name="localTasksCounter" value="12" />
+    <task id="LOCAL-00012" summary="Added the undo function">
+      <created>1652099718050</created>
+      <option name="number" value="00012" />
+      <option name="presentableId" value="LOCAL-00012" />
+      <option name="project" value="LOCAL" />
+      <updated>1652099718050</updated>
+    </task>
+    <option name="localTasksCounter" value="13" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -192,6 +199,7 @@
     <MESSAGE value="Added functionality that updates head and tail pointers in shuffle methods" />
     <MESSAGE value="Added method to distribute the cards to the starting piles" />
     <MESSAGE value="gamelogic fixed" />
-    <option name="LAST_COMMIT_MESSAGE" value="gamelogic fixed" />
+    <MESSAGE value="Added the undo function" />
+    <option name="LAST_COMMIT_MESSAGE" value="Added the undo function" />
   </component>
 </project>
\ No newline at end of file
